# Copyright 2017 BBVA
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Manager function to deal with Vulnerability model"""

import logging

from sqlalchemy.orm import Session

from deeptracy_core.dal.vulnerability.models import Vulnerability, VulnerabilitiesInScans

log = logging.getLogger(__name__)


def get_or_create_vuln(cpe: str, cve: str, session: Session) \
        -> Vulnerability:
    """
    returns a vulnerability if not exist creates it and returns it

    :param cpe: (str) CPE that describe the vulnerability scan
    :param cve: (str) cve for the current cpe
    :param session: (Session) database session to add objects
    :return: Vulnerability
    """

    assert type(cpe) is str
    assert type(cve) is str

    instance = session.query(Vulnerability).filter(Vulnerability.cpe == cpe).filter(Vulnerability.cve == cve).first()
    if not instance:
        instance = Vulnerability(cpe=cpe, cve=cve)
        session.add(instance)
        session.commit()
    return instance


def get_or_create_vuln_in_scan(vulnerability_id: str, scan_dep_id: str, session: Session) \
        -> VulnerabilitiesInScans:
    """
    returns a vulnerability in scan if not exist creates it and returns it

    :param vulnerability_id: (str) CPE that describe the vulnerability scan
    :param scan_dep_id: (str) cve for the current cpe
    :param session: (Session) database session to add objects
    :return: VulnerabilitiesInScans
    """

    assert type(vulnerability_id) is str
    assert type(scan_dep_id) is str

    instance = session.query(VulnerabilitiesInScans)\
        .filter(VulnerabilitiesInScans.vulnerability_id == vulnerability_id)\
        .filter(VulnerabilitiesInScans.scan_dep_id == scan_dep_id).first()
    if not instance:
        instance = VulnerabilitiesInScans(vulnerability_id=vulnerability_id, scan_dep_id=scan_dep_id)
        session.add(instance)
        session.commit()
    return instance


def get_vulns_for_cpe(cpe: str, session: Session) \
        -> Vulnerability:
    """
    returns all vulnerabilities in scans that match with this cpe

    :param cpe: (str) CPE that describe the vulnerability scan
    :param session: (Session) database session to add objects
    :return: Vulnerability
    """

    assert type(cpe) is str

    return session.query(Vulnerability)\
        .filter(Vulnerability.cpe == cpe)\
        .all()


def add_vulns_in_scan_dep(cpe: str, cves: list, scan_dep_id: str, session: Session) -> Vulnerability:
    """
    returns all vulnerabilities in scans that match with this cpe

    :param cpe: (str) CPE that describe the vulnerability scan
    :param cves: (list) CVE list that describe the vulnerability scan
    :param scan_dep_id: (str) Id for Scan Dep that describe the scan dependency
    :param session: (Session) database session to add objects
    :return: Vulnerability
    """

    assert type(cpe) is str
    assert type(cves) is list
    assert type(scan_dep_id) is str

    def create_vulnerability_in_scan(cve_dict: dict):
        vuln = get_or_create_vuln(cpe, cve_dict['cve'], session)
        return VulnerabilitiesInScans(vulnerability_id=vuln.id, scan_dep_id=scan_dep_id)
    vulns_in_scan_created = [create_vulnerability_in_scan(cve_dict) for cve_dict in cves]
    session.add_all(vulns_in_scan_created)
    session.commit()
    return vulns_in_scan_created
